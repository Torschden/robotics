classdef PlaneForceSimulation < handle

    properties
        center_pos  = [0; 0; 0]     % Plane center xyz
        orientation = [0; 0; 0]     % Plane orientation rpy
        mass        = 10            % Mass of the plane (kg)
        inertia     = eye(3) * 2    % Inertia tensor (kg⋅m²)
        
        % Rotation matrix from body frame to world frame
        R_body_to_world
        
        points_body = [] % Points above
        lever_arms = [] % Lever arms
        
        % Applied forces and torques at center
        applied_force = [0; 0; 0]      % [Fx; Fy; Fz] in world frame
        applied_torque = [0; 0; 0]     % [Tx; Ty; Tz] in world frame

        linear_acceleration = [0; 0; 0]    % Linear acceleration at center
        angular_acceleration = [0; 0; 0]   % Angular acceleration at center
        
        % Current velocities (for simulation)
        velocity = [0; 0; 0]
        angular_velocity = [0; 0; 0]
        
        fig_handle
        ax_handle
        plane_handle
        points_handle
        force_handles
        acceleration_handles
    end
    
    methods
        function obj = PlaneForceSimulation()
            obj.updateRotationMatrix();
            obj.setupVisualization();
        end
        
        function updateRotationMatrix(obj)
            % Update rotation matrix from Euler angles (ZYX convention)
            roll = obj.orientation(1);
            pitch = obj.orientation(2);
            yaw = obj.orientation(3);
            
            % Individual rotation matrices
            Rx = [1 0 0; 0 cos(roll) -sin(roll); 0 sin(roll) cos(roll)];
            Ry = [cos(pitch) 0 sin(pitch); 0 1 0; -sin(pitch) 0 cos(pitch)];
            Rz = [cos(yaw) -sin(yaw) 0; sin(yaw) cos(yaw) 0; 0 0 1];
            
            % Combined rotation matrix (ZYX convention)
            obj.R_body_to_world = Rz * Ry * Rx;
        end
        
        function setPlanePose(obj, position, orientation)
            % Set plane position and orientation
            % position: [x; y; z] in world coordinates
            % orientation: [roll; pitch; yaw] in radians
            obj.center_pos = position(:);
            obj.orientation = orientation(:);
            obj.updateRotationMatrix();
        end
        
        function setPlaneProperties(obj,mass,inertia)
            obj.mass = mass;
            obj.inertia = inertia;
        end

        function addPoint(obj, point_body)
            % Add a point above the plane in body frame coordinates
            % point_body: [x; y; z] relative to plane center in body frame
            obj.points_body = [obj.points_body, point_body(:)];
            obj.lever_arms = [obj.lever_arms, point_body(:)];
        end
        
        function clearPoints(obj)
            % Clear all points
            obj.points_body = [];
            obj.lever_arms = [];
        end
        
        function setForceAndTorque(obj, force_world, torque_world)
            obj.applied_force = force_world(:);
            obj.applied_torque = torque_world(:);
            % acceleration center
            obj.linear_acceleration = obj.applied_force / obj.mass;
            obj.angular_acceleration = obj.inertia \ obj.applied_torque;
        end
        
        function [accelerations_world, angular_accelerations_world] = calculatePointAccelerations(obj)
            % Calculate forces at each point due to applied force and torque
            % Returns:
            % forces_world: 3xN matrix of forces at each point in world frame
            % torques_world: 3xN matrix of torques at each point in world frame
            
            n_points = size(obj.points_body, 2);
            forces_world = zeros(3, n_points);
            torques_world = zeros(3, n_points);
            
            if n_points == 0
                return;
            end
            
            % For each point, calculate the force due to:
            % 1. Direct translation of applied force
            % 2. Force due to applied torque via lever arm
            
            for i = 1:n_points
                lever_arm_body = obj.lever_arms(:, i);
                lever_arm_world = obj.R_body_to_world * lever_arm_body;
                
                % Direct force translation (same force at each point)
                force_direct = obj.applied_force;
                
                % Force due to applied torque (F = ω × r, where ω is angular acceleration)
                % For visualization purposes, we'll assume torque creates angular acceleration
                % and calculate the resulting linear acceleration at the point
                torque_body = obj.R_body_to_world' * obj.applied_torque;
                force_from_torque_body = cross(torque_body, lever_arm_body);
                force_from_torque_world = obj.R_body_to_world * force_from_torque_body;
                
                % Total force at point
                forces_world(:, i) = force_direct + force_from_torque_world;
                
                % Torque at point (assuming point can also rotate)
                torques_world(:, i) = obj.applied_torque;
            end
        end
        
        function points_world = getPointsWorldFrame(obj)
            % Get point positions in world frame
            points_world = zeros(3, size(obj.points_body, 2));
            for i = 1:size(obj.points_body, 2)
                points_world(:, i) = obj.center_pos + obj.R_body_to_world * obj.points_body(:, i);
            end
        end
        
        function setupVisualization(obj)
            % Setup 3D visualization
            obj.fig_handle = figure('Name', '6-DOF Plane Force Simulation', 'Position', [100 100 1000 800]);
            obj.ax_handle = axes('Parent', obj.fig_handle);
            
            hold(obj.ax_handle, 'on');
            grid(obj.ax_handle, 'on');
            axis(obj.ax_handle, 'equal');
            xlabel(obj.ax_handle, 'X (m)');
            ylabel(obj.ax_handle, 'Y (m)');
            zlabel(obj.ax_handle, 'Z (m)');
            title(obj.ax_handle, '6-DOF Plane with Force Translation');
            view(obj.ax_handle, 45, 30);
        end
     
        function updateVisualization(obj, force_scale)
            % Update the 3D visualization
            if nargin < 2
                force_scale = 0.1; % Scale factor for force vectors
            end

            % Clear previous plots
            delete(obj.plane_handle);
            delete(obj.points_handle);
            if ~isempty(obj.force_handles)
                delete(obj.force_handles);
            end

            % Draw plane (as a square in the XY plane of body frame)
            plane_size = 4.5;
            plane_corners_body = [
                -plane_size/2, plane_size/2, plane_size/2, -plane_size/2;
                -plane_size/2, -plane_size/2, plane_size/2, plane_size/2;
                0, 0, 0, 0
            ];

            % Transform to world frame
            plane_corners_world = zeros(size(plane_corners_body));
            for i = 1:4
                plane_corners_world(:, i) = obj.center_pos + obj.R_body_to_world * plane_corners_body(:, i);
            end

            % Plot plane
            obj.plane_handle = patch(obj.ax_handle, ...
                plane_corners_world(1, :), plane_corners_world(2, :), plane_corners_world(3, :), ...
                'blue', 'FaceAlpha', 0.3, 'EdgeColor', 'blue', 'LineWidth', 2);

            % Draw points and their forces
            if ~isempty(obj.points_body)
                points_world = obj.getPointsWorldFrame();
                [forces_world, ~] = obj.calculatePointForces();

                % Plot points
                obj.points_handle = scatter3(obj.ax_handle, ...
                    points_world(1, :), points_world(2, :), points_world(3, :), ...
                    100, 'red', 'filled', 'MarkerEdgeColor', 'black');

                % Plot force vectors at points
                obj.force_handles = [];
                for i = 1:size(points_world, 2)
                    % Force vector
                    force_vec = forces_world(:, i) * force_scale;
                    h = quiver3(obj.ax_handle, ...
                        points_world(1, i), points_world(2, i), points_world(3, i), ...
                        force_vec(1), force_vec(2), force_vec(3), ...
                        'magenta', 'LineWidth', 2, 'MaxHeadSize', 0.2);
                    obj.force_handles = [obj.force_handles, h];

                    % Connect point to plane center
                    z_plane = obj.center_pos(3);  
                    plot3(obj.ax_handle, ...
                          [points_world(1, i), points_world(1, i)], ...  % same x
                          [points_world(2, i), points_world(2, i)], ...  % same y
                          [points_world(3, i), z_plane], ...            % z from point down to plane
                          'k-', 'LineWidth', 1);
                end
            end

            % Draw applied force and torque at center
            if norm(obj.applied_force) > 0
                force_vec = obj.applied_force * force_scale;
                quiver3(obj.ax_handle, ...
                    obj.center_pos(1), obj.center_pos(2), obj.center_pos(3), ...
                    force_vec(1), force_vec(2), force_vec(3), ...
                    'cyan', 'LineWidth', 3, 'MaxHeadSize', 0.15);
            end

            if norm(obj.applied_torque) > 0
                torque_vec = obj.applied_torque * force_scale;
                quiver3(obj.ax_handle, ...
                    obj.center_pos(1), obj.center_pos(2), obj.center_pos(3), ...
                    torque_vec(1), torque_vec(2), torque_vec(3), ...
                    'yellow', 'LineWidth', 3, 'MaxHeadSize', 0.15);
            end

            % Set axis limits
            all_points = [obj.center_pos, obj.getPointsWorldFrame()];
            if ~isempty(all_points)
                % margin = 3;
                % xlim(obj.ax_handle, [min(all_points(1, :)) - margin, max(all_points(1, :)) + margin]);
                % ylim(obj.ax_handle, [min(all_points(2, :)) - margin, max(all_points(2, :)) + margin]);
                % zlim(obj.ax_handle, [min(all_points(3, :)) - margin, max(all_points(3, :)) + margin]);
                % constant 
                xlim(obj.ax_handle, [-4,4]);
                ylim(obj.ax_handle, [-4,4]);
                zlim(obj.ax_handle, [-4,4]);
            end

            % Add legend
            legend(obj.ax_handle, ...
                'Location', 'best', 'FontSize', 8);
        end

        function printResults(obj)
            % Print current state and force calculations
            fprintf('\n=== Plane Force Simulation Results ===\n');
            fprintf('Plane Center Position: [%.2f, %.2f, %.2f] m\n', obj.center_pos);
            fprintf('Plane Orientation (Roll, Pitch, Yaw): [%.2f, %.2f, %.2f] rad\n', obj.orientation);
            fprintf('Applied Force: [%.2f, %.2f, %.2f] N\n', obj.applied_force);
            fprintf('Applied Torque: [%.2f, %.2f, %.2f] N⋅m\n', obj.applied_torque);
            
            if ~isempty(obj.points_body)
                points_world = obj.getPointsWorldFrame();
                [forces_world, torques_world] = obj.calculatePointForces();
                
                fprintf('\nPoint Analysis:\n');
                for i = 1:size(obj.points_body, 2)
                    fprintf('Point %d:\n', i);
                    fprintf('  Body Frame Position: [%.2f, %.2f, %.2f] m\n', obj.points_body(:, i));
                    fprintf('  World Frame Position: [%.2f, %.2f, %.2f] m\n', points_world(:, i));
                    fprintf('  Lever Arm (Body): [%.2f, %.2f, %.2f] m\n', obj.lever_arms(:, i));
                    fprintf('  Resulting Force: [%.2f, %.2f, %.2f] N\n', forces_world(:, i));
                    fprintf('  Resulting Torque: [%.2f, %.2f, %.2f] N⋅m\n', torques_world(:, i));
                    fprintf('  Force Magnitude: %.2f N\n\n', norm(forces_world(:, i)));
                end
            end
        end
       
        function simulateMotion(obj, dt, n_steps, force_traj, torque_traj)
            % Simulate motion over time with time-varying force/torque

            if nargin < 2, dt = 0.1; end
            if nargin < 3, n_steps = 50; end
            if nargin < 4, force_traj = [zeros(3,1), obj.applied_force]; end
            if nargin < 5, torque_traj = [zeros(3,1), obj.applied_torque]; end

            % Interpolate if only start/goal provided
            if size(force_traj,2) == 2
                force_traj = repmat(force_traj(:,1),1,n_steps) + ...
                    (repmat((0:(n_steps-1))/(n_steps-1),3,1) .* repmat(force_traj(:,2)-force_traj(:,1),1,n_steps));
            end
            if size(torque_traj,2) == 2
                torque_traj = repmat(torque_traj(:,1),1,n_steps) + ...
                    (repmat((0:(n_steps-1))/(n_steps-1),3,1) .* repmat(torque_traj(:,2)-torque_traj(:,1),1,n_steps));
            end

            fprintf('Simulating motion for %.1f seconds...\n', dt * n_steps);
            
            % Simple physics parameters
            mass = 10; % kg
            inertia = eye(3) * 2; % kg⋅m²
            
            % Initial conditions
            velocity = [0; 0; 0];
            angular_velocity = [0; 0; 0];
            
            % Trajectory storage
            pose_traj = zeros(6, n_steps); % [x;y;z;roll;pitch;yaw]
            force_log = zeros(3, n_steps);
            torque_log = zeros(3, n_steps);
            point_force_traj = zeros(3, size(obj.points_body,2), n_steps);
            point_torque_traj = zeros(3, size(obj.points_body,2), n_steps);

            for step = 1:n_steps
                % Use interpolated force and torque for each step
                obj.applied_force = force_traj(:,step);
                obj.applied_torque = torque_traj(:,step);

                % Calculate accelerations
                acceleration = obj.applied_force / mass;
                angular_acceleration = inertia \ obj.applied_torque;
                
                % Update velocities
                velocity = velocity + acceleration * dt;
                angular_velocity = angular_velocity + angular_acceleration * dt;
                
                % Update position and orientation   
                obj.center_pos = obj.center_pos + velocity * dt;
                obj.orientation = obj.orientation + angular_velocity * dt;
                obj.updateRotationMatrix();
                
                % Store trajectory
                pose_traj(:, step) = [obj.center_pos; obj.orientation];
                force_log(:, step) = obj.applied_force;
                torque_log(:, step) = obj.applied_torque;
                [forces_world, torques_world] = obj.calculatePointForces();
                point_force_traj(:,:,step) = forces_world;
                point_torque_traj(:,:,step) = torques_world;

                % Update visualization every few steps
                if mod(step, 5) == 0
                    obj.updateVisualization(0.1);
                    title(obj.ax_handle, sprintf('Step %d/%d - Time: %.1fs', step, n_steps, step*dt));
                    drawnow;
                    pause(0.05);
                end
            end

            obj.printResults();

            % Print initial, middle, and final torque
            fprintf('\nTorque at t=0:      [%.2f, %.2f, %.2f] N·m\n', torque_log(:,1));
            fprintf('Torque at t/2:     [%.2f, %.2f, %.2f] N·m\n', torque_log(:,round(n_steps/2)));
            fprintf('Torque at t_final: [%.2f, %.2f, %.2f] N·m\n', torque_log(:,n_steps));

            % --- Trajectory Plots ---
            t = (0:n_steps-1)*dt;
            figure('Name','Plane Pose Trajectory');
            subplot(2,1,1);
            plot(t, pose_traj(1,:), 'r', t, pose_traj(2,:), 'g', t, pose_traj(3,:), 'b');
            xlabel('Time (s)'); ylabel('Position (m)');
            legend('X','Y','Z'); title('COG Position Trajectory');
            grid on;
            subplot(2,1,2);
            plot(t, pose_traj(4,:), 'r', t, pose_traj(5,:), 'g', t, pose_traj(6,:), 'b');
            xlabel('Time (s)'); ylabel('Orientation (rad)');
            legend('Roll','Pitch','Yaw'); title('COG Orientation Trajectory');
            grid on;

            figure('Name','Force Trajectories');
            subplot(2,1,1);
            plot(t, force_log(1,:), 'r', t, force_log(2,:), 'g', t, force_log(3,:), 'b');
            xlabel('Time (s)'); ylabel('Force at COG (N)');
            legend('Fx','Fy','Fz'); title('COG Force Trajectory');
            grid on;
            subplot(2,1,2);
            hold on;
            colors = lines(size(obj.points_body,2));
            for i = 1:size(obj.points_body,2)
                plot(t, squeeze(point_force_traj(1,i,:)), '-', 'Color', colors(i,:), 'DisplayName',sprintf('Point %d Fx',i));
                plot(t, squeeze(point_force_traj(2,i,:)), '--', 'Color', colors(i,:), 'DisplayName',sprintf('Point %d Fy',i));
                plot(t, squeeze(point_force_traj(3,i,:)), ':', 'Color', colors(i,:), 'DisplayName',sprintf('Point %d Fz',i));
            end
            xlabel('Time (s)'); ylabel('Force at Points (N)');
            legend('show'); title('Forces at Points Trajectory');
            grid on;
            hold off;

            % --- Torque Trajectory Plots ---
            torque_traj = repmat(obj.applied_torque, 1, n_steps); % torque at COG
            point_torque_traj = zeros(3, size(obj.points_body,2), n_steps); % torques at points
            for step = 1:n_steps
                [~, torques_world] = obj.calculatePointForces();
                point_torque_traj(:,:,step) = torques_world;
            end

            figure('Name','Torque Trajectories');
            subplot(2,1,1);
            plot(t, torque_traj(1,:), 'r', t, torque_traj(2,:), 'g', t, torque_traj(3,:), 'b');
            xlabel('Time (s)'); ylabel('Torque at COG (N·m)');
            legend('Tx','Ty','Tz'); title('COG Torque Trajectory');
            grid on;
            subplot(2,1,2);
            hold on;
            for i = 1:size(obj.points_body,2)
                plot(t, squeeze(point_torque_traj(1,i,:)), '-', 'Color', colors(i,:), 'DisplayName',sprintf('Point %d Tx',i));
                plot(t, squeeze(point_torque_traj(2,i,:)), '--', 'Color', colors(i,:), 'DisplayName',sprintf('Point %d Ty',i));
                plot(t, squeeze(point_torque_traj(3,i,:)), ':', 'Color', colors(i,:), 'DisplayName',sprintf('Point %d Tz',i));
            end
            xlabel('Time (s)'); ylabel('Torque at Points (N·m)');
            legend('show'); title('Torques at Points Trajectory');
            grid on;
            hold off;
        end
    end
end

%% Example Usage Script


%% Utility Functions
function demonstrateSphericalCoordinates()
    % Demonstrate spherical coordinate system
    fprintf('\n=== Spherical Coordinates Demonstration ===\n');
    
    % Create points in spherical coordinates
    r = 3;              % radius
    theta = pi/4;       % azimuthal angle (0 to 2π)
    phi = pi/3;         % polar angle (0 to π)
    
    % Convert to Cartesian
    x = r * sin(phi) * cos(theta);
    y = r * sin(phi) * sin(theta);
    z = r * cos(phi);
    
    fprintf('Spherical: (r=%.2f, θ=%.2f, φ=%.2f)\n', r, theta, phi);
    fprintf('Cartesian: (x=%.2f, y=%.2f, z=%.2f)\n', x, y, z);
    
    % Visualize
    figure('Name', 'Spherical Coordinates');
    [X, Y, Z] = sphere(20);
    surf(X*r, Y*r, Z*r, 'FaceAlpha', 0.1, 'EdgeAlpha', 0.2);
    hold on;
    
    % Plot point
    plot3(x, y, z, 'ro', 'MarkerSize', 10, 'MarkerFaceColor', 'red');
    
    % Plot coordinate lines
    plot3([0, x], [0, 0], [0, 0], 'r--', 'LineWidth', 2); % to projection on xy
    plot3([x, x], [0, y], [0, 0], 'g--', 'LineWidth', 2);
    plot3([x, x], [y, y], [0, z], 'b--', 'LineWidth', 2);
    plot3([0, x], [0, y], [0, z], 'k-', 'LineWidth', 3);   % radius vector
    
    axis equal;
    grid on;
    xlabel('X'); ylabel('Y'); zlabel('Z');
    title('Spherical Coordinate System');
    legend('Unit Sphere', 'Point', 'X projection', 'Y projection', 'Z projection', 'Radius Vector');
end

%% Main execution
% Uncomment the line below to run the example
% runPlaneForceExample();

% Uncomment the line below to see spherical coordinates demo
% demonstrateSphericalCoordinates();
% Create simulation
